# [米勒罗宾-大素数探测]()

```c++
struct miller_rabin
{
    // #define uhh unsigned __int128 
    
    uhh qmul(uhh a, uhh b, uhh mod)
    {
        if (b == 0) return 0;
        uhh t = qmul(a, b >> 1, mod);
        t = t * 2 % mod;
        if (b & 1) t = (t + a) % mod;
        return t;
    }

    uhh qpow(uhh a, uhh b, uhh mod)
    {
        if (!b) return 1;
        uhh t = qpow(a, b >> 1, mod);
        t = qmul(t, t, mod);
        if (b & 1) t = qmul(t, a, mod);
        return t;
    }

    bool may_be_prime(uhh val, uhh key = 30)
    {
        uhh u = val - 1;
        uhh t = 0;
        while ((u & 1) == 0) u = u >> 1, t ++;
        uhh x1, x2;
        x1 = qpow(key, u, val);
        for (uhh i = 1; i <= t; i ++)
        {
            x2 = qpow(x1, 2, val);
            if (x2 == 1 && x1 != 1 && x1 != val - 1) return false;
            x1 = x2;
        }
        if (x1 != 1) return false;
        return true;
    }

    bool check(uhh val, uhh times)
    {
        srand(time(0));
        if (val < 2) return false;
        if ((val & 1) == 0) return val == 2;
        for (uhh i = 0; i < times && i < val; i ++)
        {
            uhh key = rand() % (val - 1) + 1;
            if (!may_be_prime(val, key)) return false;
        }
        return true;
    }
    
    bool operator()(uhh val, uhh times)
    {
        return check(val, times);
    }
};
```